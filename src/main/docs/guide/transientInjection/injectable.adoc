While not technically a true marker interface, `com.oracle.coherence.inject.Injectable` can be treated as such for
all intents and purposes.
All you need to do is add it to the `implements` clause of your class in order for injection on deserialization to
kick in:

[source,java]
----
public class InjectableBean
        implements Injectable, Serializable {

    @Inject
    private Converter<String, String> converter;

    private String text;

    InjectableBean() {
    }

    InjectableBean(String text) {
        this.text = text;
    }

    String getConvertedText() {
        return converter.convert(text);
    }
}
----

Assuming that you have the following `Converter` service implementation in your application, it will be injected
into `InjectableBean` during deserialization, and the `getConvertedText` method will return the value of the `text`
field converted to upper case:

[source,java]
----
@ApplicationScoped
public class ToUpperConverter
        implements Converter<String, String> {
    @Override
    public String convert(String s) {
        return s.toUpperCase();
    }
}
----

NOTE: If your `Injectable` class has `@PostConstruct` callback method, it will be called after the injection.
However, because we have no control over object's lifecycle after that point, `@PreDestroy` callback will *never* be called).

You should note that the above functionality is not dependent on the serialization format and will work with both
Java and POF serialization (or any other custom serializer), and for any object that is  deserialized on any Coherence
member (or even on a remote client).

While the deserialized transient objects are not true Micronaut managed beans, being able to inject Micronaut managed dependencies
into them upon deserialization will likely satisfy most dependency injection requirements you will ever have in those
application components.
